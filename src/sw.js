import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

self.skipWaiting();
clientsClaim();

cleanupOutdatedCaches();

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// Cache Supabase API responses (NetworkFirst - try network, fallback to cache)
registerRoute(
    ({ url }) => url.hostname.includes('supabase'),
    new NetworkFirst({
        cacheName: 'supabase-api-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200],
            }),
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 60 * 60 * 24, // 24 hours
            }),
        ],
        networkTimeoutSeconds: 10, // Fallback to cache after 10 seconds
    })
);

// Cache Google Fonts stylesheets
registerRoute(
    ({ url }) => url.origin === 'https://fonts.googleapis.com',
    new StaleWhileRevalidate({
        cacheName: 'google-fonts-stylesheets',
    })
);

// Cache Google Fonts webfont files
registerRoute(
    ({ url }) => url.origin === 'https://fonts.gstatic.com',
    new CacheFirst({
        cacheName: 'google-fonts-webfonts',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200],
            }),
            new ExpirationPlugin({
                maxEntries: 30,
                maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
            }),
        ],
    })
);

// Cache images
registerRoute(
    ({ request }) => request.destination === 'image',
    new CacheFirst({
        cacheName: 'images-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200],
            }),
            new ExpirationPlugin({
                maxEntries: 60,
                maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
            }),
        ],
    })
);

// Existing notification logic
let timeoutIds = [];
const dayMap = { 'Senin': 1, 'Selasa': 2, 'Rabu': 3, 'Kamis': 4, 'Jumat': 5, 'Sabtu': 6, 'Minggu': 0 };

function showNotification(item) {
    const className = item.className || item.class_id;
    self.registration.showNotification('Pengingat Kelas: ' + item.subject, {
        body: 'Kelas ' + className + ' akan dimulai pada pukul ' + item.start_time + '.',
        icon: '/logo.svg', // Use new SVG logo for notifications
        requireInteraction: true,
        tag: item.id,
    });
}

function scheduleNotifications(schedule) {
    clearScheduledNotifications();
    const now = new Date();
    const todayIndex = now.getDay();
    const upcomingClasses = schedule.filter(item => {
        if (dayMap[item.day] !== todayIndex) return false;
        const [hours, minutes] = item.start_time.split(':');
        const classTime = new Date();
        classTime.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
        return classTime > now;
    });
    upcomingClasses.forEach(item => {
        const [hours, minutes] = item.start_time.split(':');
        const classTime = new Date();
        classTime.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
        // Remind 5 minutes before
        const notificationTime = new Date(classTime.getTime() - 5 * 60 * 1000);
        if (notificationTime > now) {
            const delay = notificationTime.getTime() - now.getTime();
            const id = setTimeout(() => {
                showNotification(item);
            }, delay);
            timeoutIds.push(id);
        }
    });
}

function clearScheduledNotifications() {
    timeoutIds.forEach(clearTimeout);
    timeoutIds = [];
}

let taskTimeoutIds = [];

function showTaskNotification(task) {
    self.registration.showNotification('Pengingat Tugas: ' + task.title, {
        body: 'Tugas "' + task.title + '" jatuh tempo hari ini.',
        icon: '/logo.svg',
        requireInteraction: true,
        tag: 'task-' + task.id,
    });
}

function scheduleTaskNotifications(tasks) {
    clearScheduledTaskNotifications();
    const now = new Date();

    tasks.forEach(task => {
        if (task.status === 'done' || !task.due_date) return;

        const dueDate = new Date(task.due_date);
        dueDate.setHours(0, 0, 0, 0);

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // If due date is today
        if (dueDate.getTime() === today.getTime()) {
            // Schedule for 9 AM or now if it's past 9 AM but still today
            const notificationTime = new Date();
            notificationTime.setHours(9, 0, 0, 0);

            if (notificationTime < now) {
                // If it's already past 9 AM, verify if we haven't notified yet (simplified: just notify now if it's not too late in the day)
                // For simplicity in this demo, we'll notify 1 minute from now if it's the first time loading
                const delay = 60 * 1000; // 1 minute delay
                const id = setTimeout(() => showTaskNotification(task), delay);
                taskTimeoutIds.push(id);
            } else {
                const delay = notificationTime.getTime() - now.getTime();
                const id = setTimeout(() => showTaskNotification(task), delay);
                taskTimeoutIds.push(id);
            }
        }
    });
}

function clearScheduledTaskNotifications() {
    taskTimeoutIds.forEach(clearTimeout);
    taskTimeoutIds = [];
}

self.addEventListener('message', (event) => {
    if (event.data) {
        if (event.data.type === 'SCHEDULE_UPDATED') {
            scheduleNotifications(event.data.payload);
        } else if (event.data.type === 'CLEAR_SCHEDULE') {
            clearScheduledNotifications();
        } else if (event.data.type === 'TASKS_UPDATED') {
            scheduleTaskNotifications(event.data.payload);
        }
    }
});
